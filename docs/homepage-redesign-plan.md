# План обновления главной страницы

## Цели и контекст
- Убрать вертикальную прокрутку на главной странице за счёт компактной раскладки.
- Выделить голосового бота (VoiceConsole) как основной инструмент ввода и расположить остальные элементы вокруг него.
- Аккуратно довести интеграцию Live API: новые компоненты (`VoiceConsole`, `VoiceGuide`) и стили уже подготовлены, но не вставлены в `App.tsx`.
- Сохранить рабочее состояние приложения после каждого этапа, минимизируя риск сбоев.

## Ограничения и риски
- Текущие строки интерфейса отображаются некорректно из-за кодировки (файлы сохранены в Windows-1251). Любые правки нужно переводить в UTF-8, чтобы Vite рендерил текст нормально.
- `VoiceConsole` пока не подключён к дереву компонентов — при встраивании стоит проверять зависимости (`contexts/LiveAPIContext.tsx`, `hooks/media/use-live-api.ts`).
- После перестройки макета необходимо убедиться, что Playwright тесты и сборка (`npm run lint`, `npm run test`, `npm run build`) проходят.

## Дорожная карта изменений

### Этап 0. Подготовка
1. Проверить текущие зависимости и состояния стора (`useUI`, `useUser`) в `frontend/src/App.tsx`, чтобы понимать, какие блоки активны по умолчанию.
2. Перевести ключевые файлы (`App.tsx`, `VoiceConsole.tsx`, `VoiceGuide.tsx`, `App.css`, e2e-тесты) на UTF-8 без BOM.
3. Убедиться, что `frontend/src/main.tsx` импортирует `LiveAPIProvider` из `contexts/LiveAPIContext.tsx` и что Vite тянет файлы вне `src` (при необходимости — относительные пути поправить).

### Этап 1. Включение голосовых компонентов
1. Импортировать `VoiceConsole` и `VoiceGuide` в `frontend/src/App.tsx`.
2. Добавить их в JSX: `VoiceConsole` — центральная колонка, `VoiceGuide` — вспомогательный блок рядом.
3. Протянуть пропсы в `VoiceConsole` (регистрация, логин, создание идеи, обновление списка) и убедиться, что Live API контекст доступен.
4. После правок убедиться, что приложение запускается (`npm run dev`) и голосовой блок монтируется без ошибок.

### Этап 2. Перестройка макета под безскролловую страницу
1. Переработать структуру контейнера в `App.tsx`, чтобы использовать трёхколоночную сетку (`центральная колонка = VoiceConsole`).
2. Ограничить высоту колонок и блоков, добавить внутренние скроллы там, где допустимо (например, списки заявок), чтобы основная страница не требовала внешнего скролла.
3. Переставить элементы: авторизация и форма идеи — левая колонка; VoiceConsole + ключевые CTA — центр; служебные панели (назначения, очередь писем, аудит) — правая колонка.
4. В `App.css` обновить `grid-template-columns`, отступы и sticky-поведение для центрального блока, чтобы он всегда оставался в центре.

### Этап 3. Доработка визуальных акцентов
1. Настроить отдельную цветовую палитру/фон для VoiceConsole (рамка, тень, крупный заголовок), чтобы визуально выделить блок.
2. Привести кнопки и заголовки к единому стилю (использовать переменные `--accent`, `--surface` из `App.css`).
3. Обновить классы для элементов, у которых изменилось позиционирование (например, секции администратора) и добавить минимальные комментарии к сложным CSS-правилам.
4. Проверить адаптивность: медиазапросы для ширины <1100px и <768px должны корректно складывать колонки и не давать общему контейнеру скроллиться более чем на экран.

### Этап 4. Текст и локализация
1. Исправить все строки интерфейса в `App.tsx`, `VoiceConsole.tsx`, `VoiceGuide.tsx`, `frontend/e2e/example.spec.ts` на читабельный русский в UTF-8.
2. Синхронизировать тестовые селекторы (`data-testid`) после перестановки блоков.
3. Проверить, что e2e-тесты ищут корректные заголовки (обновить значения в `example.spec.ts`).

### Этап 5. Проверки и стабилизация
1. Запустить линтер и типы (`npm run lint`, `npm run type-check`, если есть).
2. Собрать проект (`npm run build`) и прогнать Playwright-тесты (`npx playwright test`).
3. Зафиксировать результаты, обновить документацию (README, если требуется) и подготовить PR/коммит.

---

## Контрольные точки
- После этапа 1 голосовая консоль интегрирована и доступна, но макет ещё не финализирован.
- После этапа 2 страница не требует внешнего скролла, VoiceConsole — в центре.
- После этапа 3 визуальная иерархия выстроена, центральный блок выделяется.
- После этапа 4 UI и тесты согласованы по тексту/локализации.
- После этапа 5 проект проверен сборкой и автоматическими тестами.

Каждый этап вносит ограниченные изменения и завершает их самостоятельной проверкой, что помогает вовремя отлавливать ошибки и не ломать общую функциональность.
